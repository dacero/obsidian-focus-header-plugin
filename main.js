/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FocusHeaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_language = require("@codemirror/language");
var FocusHeaderPlugin = class extends import_obsidian.Plugin {
  onload() {
    this.addCommand({
      id: "focus-on-current-header-smart",
      name: "Focus on Current Header",
      editorCallback: (editor, view) => {
        this.focusOnCurrentHeader(editor);
      }
    });
    this.addCommand({
      id: "focus-next-sibling-header",
      name: "Focus on Next Header",
      editorCallback: (editor, view) => {
        this.focusOnNextSibling(editor);
      }
    });
    this.addCommand({
      id: "focus-previous-sibling-header",
      name: "Focus on Previous Header",
      editorCallback: (editor, view) => {
        this.focusOnPreviousSibling(editor);
      }
    });
  }
  focusOnCurrentHeader(editor) {
    var _a, _b;
    const cm = editor.cm;
    const state = cm.state;
    const cursorLine = editor.getCursor().line;
    const lines = editor.getValue().split("\n");
    const headers = [];
    let lastByLevel = {};
    for (let i = 0; i < lines.length; i++) {
      const match = lines[i].match(/^(#+)\s/);
      if (match) {
        const level = match[1].length;
        const node = { line: i, level };
        for (let l = level - 1; l >= 1; l--) {
          if (lastByLevel[l]) {
            node.parent = lastByLevel[l];
            break;
          }
        }
        headers.push(node);
        lastByLevel[level] = node;
      }
    }
    let currentHeader;
    for (let i = headers.length - 1; i >= 0; i--) {
      if (headers[i].line <= cursorLine) {
        currentHeader = headers[i];
        break;
      }
    }
    if (!currentHeader)
      return;
    const unfoldLines = /* @__PURE__ */ new Set();
    let ancestor = currentHeader;
    while (ancestor) {
      unfoldLines.add(ancestor.line);
      ancestor = ancestor.parent;
    }
    const collectDescendants = (node) => {
      unfoldLines.add(node.line);
      for (const child of headers) {
        if (child.parent === node) {
          collectDescendants(child);
        }
      }
    };
    collectDescendants(currentHeader);
    const effects = [];
    for (const header of headers) {
      const from = state.doc.line(header.line + 1).from;
      const range = (0, import_language.foldable)(state, from);
      if (!range)
        continue;
      if (unfoldLines.has(header.line)) {
        effects.push(import_language.unfoldEffect.of(range));
      } else {
        effects.push(import_language.foldEffect.of(range));
      }
    }
    cm.dispatch({ effects });
    const pos = state.doc.line(currentHeader.line + 1).from;
    cm.scrollDOM.scrollTop = (_b = (_a = cm.coordsAtPos(pos)) == null ? void 0 : _a.top) != null ? _b : 0;
  }
  focusOnNextSibling(editor) {
    var _a, _b;
    const cm = editor.cm;
    const state = cm.state;
    const cursorLine = editor.getCursor().line;
    const lines = editor.getValue().split("\n");
    const headers = [];
    let lastByLevel = {};
    for (let i = 0; i < lines.length; i++) {
      const match = lines[i].match(/^(#+)\s/);
      if (match) {
        const level2 = match[1].length;
        const node = { line: i, level: level2 };
        for (let l = level2 - 1; l >= 1; l--) {
          if (lastByLevel[l]) {
            node.parent = lastByLevel[l];
            break;
          }
        }
        headers.push(node);
        lastByLevel[level2] = node;
      }
    }
    let currentHeaderIndex = -1;
    for (let i = headers.length - 1; i >= 0; i--) {
      if (headers[i].line <= cursorLine) {
        currentHeaderIndex = i;
        break;
      }
    }
    if (currentHeaderIndex === -1)
      return;
    const currentHeader = headers[currentHeaderIndex];
    const level = currentHeader.level;
    let nextSibling;
    for (let i = currentHeaderIndex + 1; i < headers.length; i++) {
      if (headers[i].level === level && headers[i].parent === currentHeader.parent) {
        nextSibling = headers[i];
        break;
      }
      if (headers[i].level <= level)
        break;
    }
    if (!nextSibling)
      return;
    const unfoldLines = /* @__PURE__ */ new Set();
    let ancestor = nextSibling;
    while (ancestor) {
      unfoldLines.add(ancestor.line);
      ancestor = ancestor.parent;
    }
    const collectDescendants = (node) => {
      unfoldLines.add(node.line);
      for (const child of headers) {
        if (child.parent === node) {
          collectDescendants(child);
        }
      }
    };
    collectDescendants(nextSibling);
    const effects = [];
    for (const header of headers) {
      const from = state.doc.line(header.line + 1).from;
      const range = (0, import_language.foldable)(state, from);
      if (!range)
        continue;
      if (unfoldLines.has(header.line)) {
        effects.push(import_language.unfoldEffect.of(range));
      } else {
        effects.push(import_language.foldEffect.of(range));
      }
    }
    cm.dispatch({ effects });
    const pos = state.doc.line(nextSibling.line + 1).from;
    cm.scrollDOM.scrollTop = (_b = (_a = cm.coordsAtPos(pos)) == null ? void 0 : _a.top) != null ? _b : 0;
    editor.setCursor({ line: nextSibling.line, ch: 0 });
  }
  focusOnPreviousSibling(editor) {
    var _a, _b;
    const cm = editor.cm;
    const state = cm.state;
    const cursorLine = editor.getCursor().line;
    const lines = editor.getValue().split("\n");
    const headers = [];
    let lastByLevel = {};
    for (let i = 0; i < lines.length; i++) {
      const match = lines[i].match(/^(#+)\s/);
      if (match) {
        const level2 = match[1].length;
        const node = { line: i, level: level2 };
        for (let l = level2 - 1; l >= 1; l--) {
          if (lastByLevel[l]) {
            node.parent = lastByLevel[l];
            break;
          }
        }
        headers.push(node);
        lastByLevel[level2] = node;
      }
    }
    let currentHeaderIndex = -1;
    for (let i = headers.length - 1; i >= 0; i--) {
      if (headers[i].line <= cursorLine) {
        currentHeaderIndex = i;
        break;
      }
    }
    if (currentHeaderIndex === -1)
      return;
    const currentHeader = headers[currentHeaderIndex];
    const level = currentHeader.level;
    let prevSibling;
    for (let i = currentHeaderIndex - 1; i >= 0; i--) {
      if (headers[i].level === level && headers[i].parent === currentHeader.parent) {
        prevSibling = headers[i];
        break;
      }
      if (headers[i].level <= level)
        break;
    }
    if (!prevSibling)
      return;
    const unfoldLines = /* @__PURE__ */ new Set();
    let ancestor = prevSibling;
    while (ancestor) {
      unfoldLines.add(ancestor.line);
      ancestor = ancestor.parent;
    }
    const collectDescendants = (node) => {
      unfoldLines.add(node.line);
      for (const child of headers) {
        if (child.parent === node) {
          collectDescendants(child);
        }
      }
    };
    collectDescendants(prevSibling);
    const effects = [];
    for (const header of headers) {
      const from = state.doc.line(header.line + 1).from;
      const range = (0, import_language.foldable)(state, from);
      if (!range)
        continue;
      if (unfoldLines.has(header.line)) {
        effects.push(import_language.unfoldEffect.of(range));
      } else {
        effects.push(import_language.foldEffect.of(range));
      }
    }
    cm.dispatch({ effects });
    const pos = state.doc.line(prevSibling.line + 1).from;
    cm.scrollDOM.scrollTop = (_b = (_a = cm.coordsAtPos(pos)) == null ? void 0 : _a.top) != null ? _b : 0;
    editor.setCursor({ line: prevSibling.line, ch: 0 });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCBFZGl0b3IsIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZm9sZEVmZmVjdCwgdW5mb2xkRWZmZWN0LCBmb2xkYWJsZSB9IGZyb20gXCJAY29kZW1pcnJvci9sYW5ndWFnZVwiO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XG5cbmludGVyZmFjZSBIZWFkZXJOb2RlIHtcbiAgbGluZTogbnVtYmVyO1xuICBsZXZlbDogbnVtYmVyO1xuICBwYXJlbnQ/OiBIZWFkZXJOb2RlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb2N1c0hlYWRlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gIG9ubG9hZCgpIHtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwiZm9jdXMtb24tY3VycmVudC1oZWFkZXItc21hcnRcIixcbiAgICAgIG5hbWU6IFwiRm9jdXMgb24gQ3VycmVudCBIZWFkZXJcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuICAgICAgICB0aGlzLmZvY3VzT25DdXJyZW50SGVhZGVyKGVkaXRvcik7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJmb2N1cy1uZXh0LXNpYmxpbmctaGVhZGVyXCIsXG4gICAgICBuYW1lOiBcIkZvY3VzIG9uIE5leHQgSGVhZGVyXCIsXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcbiAgICAgICAgdGhpcy5mb2N1c09uTmV4dFNpYmxpbmcoZWRpdG9yKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImZvY3VzLXByZXZpb3VzLXNpYmxpbmctaGVhZGVyXCIsXG4gICAgICBuYW1lOiBcIkZvY3VzIG9uIFByZXZpb3VzIEhlYWRlclwiLFxuICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNPblByZXZpb3VzU2libGluZyhlZGl0b3IpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGZvY3VzT25DdXJyZW50SGVhZGVyKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgLy8gQHRzLWlnbm9yZTogY20gaXMgbm90IGluIHRoZSBwdWJsaWMgQVBJXG4gICAgY29uc3QgY206IEVkaXRvclZpZXcgPSBlZGl0b3IuY207XG4gICAgY29uc3Qgc3RhdGUgPSBjbS5zdGF0ZTtcbiAgICBjb25zdCBjdXJzb3JMaW5lID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG4gICAgY29uc3QgbGluZXMgPSBlZGl0b3IuZ2V0VmFsdWUoKS5zcGxpdChcIlxcblwiKTtcblxuICAgIGNvbnN0IGhlYWRlcnM6IEhlYWRlck5vZGVbXSA9IFtdO1xuICAgIGxldCBsYXN0QnlMZXZlbDogeyBbbGV2ZWw6IG51bWJlcl06IEhlYWRlck5vZGUgfSA9IHt9O1xuXG4gICAgLy8gU3RlcCAxOiBCdWlsZCB0aGUgaGVhZGVyIHRyZWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKC9eKCMrKVxccy8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBub2RlOiBIZWFkZXJOb2RlID0geyBsaW5lOiBpLCBsZXZlbCB9O1xuICAgICAgICAvLyBTZXQgcGFyZW50OiBsb29rIGZvciBsYXN0IHNtYWxsZXIgbGV2ZWxcbiAgICAgICAgZm9yIChsZXQgbCA9IGxldmVsIC0gMTsgbCA+PSAxOyBsLS0pIHtcbiAgICAgICAgICBpZiAobGFzdEJ5TGV2ZWxbbF0pIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbGFzdEJ5TGV2ZWxbbF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5wdXNoKG5vZGUpO1xuICAgICAgICBsYXN0QnlMZXZlbFtsZXZlbF0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgMjogRmluZCBjdXJyZW50IGhlYWRlciBub2RlXG4gICAgbGV0IGN1cnJlbnRIZWFkZXI6IEhlYWRlck5vZGUgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgaSA9IGhlYWRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChoZWFkZXJzW2ldLmxpbmUgPD0gY3Vyc29yTGluZSkge1xuICAgICAgICBjdXJyZW50SGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50SGVhZGVyKSByZXR1cm47XG5cbiAgICAvLyBTdGVwIDM6IENvbGxlY3QgbGluZXMgdG8gdW5mb2xkIChhbmNlc3RvcnMgKyBjdXJyZW50IGhlYWRlciArIGl0cyBjaGlsZHJlbiBvbmx5KVxuICAgIGNvbnN0IHVuZm9sZExpbmVzID0gbmV3IFNldDxudW1iZXI+KCk7XG5cbiAgICAvLyBDb2xsZWN0IGFuY2VzdG9ycyAod2l0aG91dCB0aGVpciBjaGlsZHJlbilcbiAgICBsZXQgYW5jZXN0b3I6IEhlYWRlck5vZGUgfCB1bmRlZmluZWQgPSBjdXJyZW50SGVhZGVyO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgdW5mb2xkTGluZXMuYWRkKGFuY2VzdG9yLmxpbmUpO1xuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuXG4gICAgLy8gQ29sbGVjdCBjdXJyZW50IGhlYWRlciBhbmQgaXRzIGRlc2NlbmRhbnRzXG4gICAgY29uc3QgY29sbGVjdERlc2NlbmRhbnRzID0gKG5vZGU6IEhlYWRlck5vZGUpID0+IHtcbiAgICAgIHVuZm9sZExpbmVzLmFkZChub2RlLmxpbmUpO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IG5vZGUpIHtcbiAgICAgICAgICBjb2xsZWN0RGVzY2VuZGFudHMoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2xsZWN0RGVzY2VuZGFudHMoY3VycmVudEhlYWRlcik7XG5cbiAgICAvLyBTdGVwIDQ6IENyZWF0ZSBmb2xkL3VuZm9sZCBlZmZlY3RzXG4gICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xuICAgICAgY29uc3QgZnJvbSA9IHN0YXRlLmRvYy5saW5lKGhlYWRlci5saW5lICsgMSkuZnJvbTtcbiAgICAgIGNvbnN0IHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGZyb20pO1xuICAgICAgaWYgKCFyYW5nZSkgY29udGludWU7XG5cbiAgICAgIGlmICh1bmZvbGRMaW5lcy5oYXMoaGVhZGVyLmxpbmUpKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY20uZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuXG4gICAgLy8gU2Nyb2xsIHRvIGN1cnJlbnQgaGVhZGVyXG4gICAgY29uc3QgcG9zID0gc3RhdGUuZG9jLmxpbmUoY3VycmVudEhlYWRlci5saW5lICsgMSkuZnJvbTtcbiAgICBjbS5zY3JvbGxET00uc2Nyb2xsVG9wID0gY20uY29vcmRzQXRQb3MocG9zKT8udG9wID8/IDA7XG4gIH1cblxuICBmb2N1c09uTmV4dFNpYmxpbmcoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICAvLyBAdHMtaWdub3JlOiBjbSBpcyBub3QgaW4gdGhlIHB1YmxpYyBBUElcbiAgICBjb25zdCBjbTogRWRpdG9yVmlldyA9IGVkaXRvci5jbTtcbiAgICBjb25zdCBzdGF0ZSA9IGNtLnN0YXRlO1xuICAgIGNvbnN0IGN1cnNvckxpbmUgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcbiAgICBjb25zdCBsaW5lcyA9IGVkaXRvci5nZXRWYWx1ZSgpLnNwbGl0KFwiXFxuXCIpO1xuXG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVyTm9kZVtdID0gW107XG4gICAgbGV0IGxhc3RCeUxldmVsOiB7IFtsZXZlbDogbnVtYmVyXTogSGVhZGVyTm9kZSB9ID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKC9eKCMrKVxccy8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBub2RlOiBIZWFkZXJOb2RlID0geyBsaW5lOiBpLCBsZXZlbCB9O1xuICAgICAgICBmb3IgKGxldCBsID0gbGV2ZWwgLSAxOyBsID49IDE7IGwtLSkge1xuICAgICAgICAgIGlmIChsYXN0QnlMZXZlbFtsXSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBsYXN0QnlMZXZlbFtsXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLnB1c2gobm9kZSk7XG4gICAgICAgIGxhc3RCeUxldmVsW2xldmVsXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRIZWFkZXJJbmRleCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBoZWFkZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoaGVhZGVyc1tpXS5saW5lIDw9IGN1cnNvckxpbmUpIHtcbiAgICAgICAgY3VycmVudEhlYWRlckluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRIZWFkZXJJbmRleCA9PT0gLTEpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRIZWFkZXIgPSBoZWFkZXJzW2N1cnJlbnRIZWFkZXJJbmRleF07XG4gICAgY29uc3QgbGV2ZWwgPSBjdXJyZW50SGVhZGVyLmxldmVsO1xuXG4gICAgLy8gRmluZCB0aGUgbmV4dCBzaWJsaW5nXG4gICAgbGV0IG5leHRTaWJsaW5nOiBIZWFkZXJOb2RlIHwgdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IGkgPSBjdXJyZW50SGVhZGVySW5kZXggKyAxOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhlYWRlcnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIGhlYWRlcnNbaV0ucGFyZW50ID09PSBjdXJyZW50SGVhZGVyLnBhcmVudCkge1xuICAgICAgICBuZXh0U2libGluZyA9IGhlYWRlcnNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlYWRlcnNbaV0ubGV2ZWwgPD0gbGV2ZWwpIGJyZWFrOyAvLyBzdG9wIGF0IHNhbWUgb3IgaGlnaGVyLWxldmVsIGhlYWRpbmdcbiAgICB9XG5cbiAgICBpZiAoIW5leHRTaWJsaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCB1bmZvbGRMaW5lcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuXG4gICAgLy8gQWx3YXlzIHVuZm9sZCBhbmNlc3RvcnMgb2YgdGhlIG5leHQgc2libGluZ1xuICAgIGxldCBhbmNlc3RvcjogSGVhZGVyTm9kZSB8IHVuZGVmaW5lZCA9IG5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgdW5mb2xkTGluZXMuYWRkKGFuY2VzdG9yLmxpbmUpO1xuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuXG4gICAgLy8gVW5mb2xkIG5leHQgc2libGluZyBhbmQgaXRzIGRlc2NlbmRhbnRzXG4gICAgY29uc3QgY29sbGVjdERlc2NlbmRhbnRzID0gKG5vZGU6IEhlYWRlck5vZGUpID0+IHtcbiAgICAgIHVuZm9sZExpbmVzLmFkZChub2RlLmxpbmUpO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IG5vZGUpIHtcbiAgICAgICAgICBjb2xsZWN0RGVzY2VuZGFudHMoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2xsZWN0RGVzY2VuZGFudHMobmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xuICAgICAgY29uc3QgZnJvbSA9IHN0YXRlLmRvYy5saW5lKGhlYWRlci5saW5lICsgMSkuZnJvbTtcbiAgICAgIGNvbnN0IHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGZyb20pO1xuICAgICAgaWYgKCFyYW5nZSkgY29udGludWU7XG5cbiAgICAgIGlmICh1bmZvbGRMaW5lcy5oYXMoaGVhZGVyLmxpbmUpKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY20uZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuXG4gICAgY29uc3QgcG9zID0gc3RhdGUuZG9jLmxpbmUobmV4dFNpYmxpbmcubGluZSArIDEpLmZyb207XG4gICAgY20uc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IGNtLmNvb3Jkc0F0UG9zKHBvcyk/LnRvcCA/PyAwO1xuICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBuZXh0U2libGluZy5saW5lLCBjaDogMCB9KTtcbiAgfVxuXG4gIGZvY3VzT25QcmV2aW91c1NpYmxpbmcoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICAvLyBAdHMtaWdub3JlOiBjbSBpcyBub3QgaW4gdGhlIHB1YmxpYyBBUElcbiAgICBjb25zdCBjbTogRWRpdG9yVmlldyA9IGVkaXRvci5jbTtcbiAgICBjb25zdCBzdGF0ZSA9IGNtLnN0YXRlO1xuICAgIGNvbnN0IGN1cnNvckxpbmUgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcbiAgICBjb25zdCBsaW5lcyA9IGVkaXRvci5nZXRWYWx1ZSgpLnNwbGl0KFwiXFxuXCIpO1xuXG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVyTm9kZVtdID0gW107XG4gICAgbGV0IGxhc3RCeUxldmVsOiB7IFtsZXZlbDogbnVtYmVyXTogSGVhZGVyTm9kZSB9ID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKC9eKCMrKVxccy8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBub2RlOiBIZWFkZXJOb2RlID0geyBsaW5lOiBpLCBsZXZlbCB9O1xuICAgICAgICBmb3IgKGxldCBsID0gbGV2ZWwgLSAxOyBsID49IDE7IGwtLSkge1xuICAgICAgICAgIGlmIChsYXN0QnlMZXZlbFtsXSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBsYXN0QnlMZXZlbFtsXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLnB1c2gobm9kZSk7XG4gICAgICAgIGxhc3RCeUxldmVsW2xldmVsXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRIZWFkZXJJbmRleCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBoZWFkZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoaGVhZGVyc1tpXS5saW5lIDw9IGN1cnNvckxpbmUpIHtcbiAgICAgICAgY3VycmVudEhlYWRlckluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRIZWFkZXJJbmRleCA9PT0gLTEpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRIZWFkZXIgPSBoZWFkZXJzW2N1cnJlbnRIZWFkZXJJbmRleF07XG4gICAgY29uc3QgbGV2ZWwgPSBjdXJyZW50SGVhZGVyLmxldmVsO1xuXG4gICAgLy8gRmluZCB0aGUgcHJldmlvdXMgc2libGluZ1xuICAgIGxldCBwcmV2U2libGluZzogSGVhZGVyTm9kZSB8IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBpID0gY3VycmVudEhlYWRlckluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChoZWFkZXJzW2ldLmxldmVsID09PSBsZXZlbCAmJiBoZWFkZXJzW2ldLnBhcmVudCA9PT0gY3VycmVudEhlYWRlci5wYXJlbnQpIHtcbiAgICAgICAgcHJldlNpYmxpbmcgPSBoZWFkZXJzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZWFkZXJzW2ldLmxldmVsIDw9IGxldmVsKSBicmVhazsgLy8gc3RvcCBhdCBzYW1lIG9yIGhpZ2hlci1sZXZlbCBoZWFkaW5nXG4gICAgfVxuXG4gICAgaWYgKCFwcmV2U2libGluZykgcmV0dXJuO1xuXG4gICAgY29uc3QgdW5mb2xkTGluZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcblxuICAgIC8vIEFsd2F5cyB1bmZvbGQgYW5jZXN0b3JzIG9mIHRoZSBwcmV2aW91cyBzaWJsaW5nXG4gICAgbGV0IGFuY2VzdG9yOiBIZWFkZXJOb2RlIHwgdW5kZWZpbmVkID0gcHJldlNpYmxpbmc7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICB1bmZvbGRMaW5lcy5hZGQoYW5jZXN0b3IubGluZSk7XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBVbmZvbGQgcHJldmlvdXMgc2libGluZyBhbmQgaXRzIGRlc2NlbmRhbnRzXG4gICAgY29uc3QgY29sbGVjdERlc2NlbmRhbnRzID0gKG5vZGU6IEhlYWRlck5vZGUpID0+IHtcbiAgICAgIHVuZm9sZExpbmVzLmFkZChub2RlLmxpbmUpO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IG5vZGUpIHtcbiAgICAgICAgICBjb2xsZWN0RGVzY2VuZGFudHMoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2xsZWN0RGVzY2VuZGFudHMocHJldlNpYmxpbmcpO1xuXG4gICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xuICAgICAgY29uc3QgZnJvbSA9IHN0YXRlLmRvYy5saW5lKGhlYWRlci5saW5lICsgMSkuZnJvbTtcbiAgICAgIGNvbnN0IHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGZyb20pO1xuICAgICAgaWYgKCFyYW5nZSkgY29udGludWU7XG5cbiAgICAgIGlmICh1bmZvbGRMaW5lcy5oYXMoaGVhZGVyLmxpbmUpKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY20uZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuXG4gICAgY29uc3QgcG9zID0gc3RhdGUuZG9jLmxpbmUocHJldlNpYmxpbmcubGluZSArIDEpLmZyb207XG4gICAgY20uc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IGNtLmNvb3Jkc0F0UG9zKHBvcyk/LnRvcCA/PyAwO1xuICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBwcmV2U2libGluZy5saW5lLCBjaDogMCB9KTtcbiAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBNkM7QUFDN0Msc0JBQW1EO0FBU25ELElBQXFCLG9CQUFyQixjQUErQyx1QkFBTztBQUFBLEVBQ3BELFNBQVM7QUFDUCxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLGdCQUFnQixDQUFDLFFBQWdCLFNBQXVCO0FBQ3RELGFBQUsscUJBQXFCLE1BQU07QUFBQSxNQUNsQztBQUFBLElBQ0YsQ0FBQztBQUNELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sZ0JBQWdCLENBQUMsUUFBZ0IsU0FBdUI7QUFDdEQsYUFBSyxtQkFBbUIsTUFBTTtBQUFBLE1BQ2hDO0FBQUEsSUFDRixDQUFDO0FBQ0QsU0FBSyxXQUFXO0FBQUEsTUFDZCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixnQkFBZ0IsQ0FBQyxRQUFnQixTQUF1QjtBQUN0RCxhQUFLLHVCQUF1QixNQUFNO0FBQUEsTUFDcEM7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNIO0FBQUEsRUFFQSxxQkFBcUIsUUFBZ0I7QUFuQ3ZDO0FBcUNJLFVBQU0sS0FBaUIsT0FBTztBQUM5QixVQUFNLFFBQVEsR0FBRztBQUNqQixVQUFNLGFBQWEsT0FBTyxVQUFVLEVBQUU7QUFDdEMsVUFBTSxRQUFRLE9BQU8sU0FBUyxFQUFFLE1BQU0sSUFBSTtBQUUxQyxVQUFNLFVBQXdCLENBQUM7QUFDL0IsUUFBSSxjQUErQyxDQUFDO0FBR3BELGFBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsWUFBTSxR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QUFDakMsNkJBQXFCO0FBQ3JCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxRQUFJLHVCQUF1QjtBQUFJO0FBRS9CLFVBQU0sZ0JBQWdCLFFBQVEsa0JBQWtCO0FBQ2hELFVBQU0sUUFBUSxjQUFjO0FBRzVCLFFBQUk7QUFDSixhQUFTLElBQUkscUJBQXFCLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDaEQsVUFBSSxRQUFRLENBQUMsRUFBRSxVQUFVLFNBQVMsUUFBUSxDQUFDLEVBQUUsV0FBVyxjQUFjLFFBQVE7QUFDNUUsc0JBQWMsUUFBUSxDQUFDO0FBQ3ZCO0FBQUEsTUFDRjtBQUNBLFVBQUksUUFBUSxDQUFDLEVBQUUsU0FBUztBQUFPO0FBQUEsSUFDakM7QUFFQSxRQUFJLENBQUM7QUFBYTtBQUVsQixVQUFNLGNBQWMsb0JBQUksSUFBWTtBQUdwQyxRQUFJLFdBQW1DO0FBQ3ZDLFdBQU8sVUFBVTtBQUNmLGtCQUFZLElBQUksU0FBUyxJQUFJO0FBQzdCLGlCQUFXLFNBQVM7QUFBQSxJQUN0QjtBQUdBLFVBQU0scUJBQXFCLENBQUMsU0FBcUI7QUFDL0Msa0JBQVksSUFBSSxLQUFLLElBQUk7QUFDekIsaUJBQVcsU0FBUyxTQUFTO0FBQzNCLFlBQUksTUFBTSxXQUFXLE1BQU07QUFDekIsNkJBQW1CLEtBQUs7QUFBQSxRQUMxQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsdUJBQW1CLFdBQVc7QUFFOUIsVUFBTSxVQUFVLENBQUM7QUFFakIsZUFBVyxVQUFVLFNBQVM7QUFDNUIsWUFBTSxPQUFPLE1BQU0sSUFBSSxLQUFLLE9BQU8sT0FBTyxDQUFDLEVBQUU7QUFDN0MsWUFBTSxZQUFRLDBCQUFTLE9BQU8sSUFBSTtBQUNsQyxVQUFJLENBQUM7QUFBTztBQUVaLFVBQUksWUFBWSxJQUFJLE9BQU8sSUFBSSxHQUFHO0FBQ2hDLGdCQUFRLEtBQUssNkJBQWEsR0FBRyxLQUFLLENBQUM7QUFBQSxNQUNyQyxPQUFPO0FBQ0wsZ0JBQVEsS0FBSywyQkFBVyxHQUFHLEtBQUssQ0FBQztBQUFBLE1BQ25DO0FBQUEsSUFDRjtBQUVBLE9BQUcsU0FBUyxFQUFFLFFBQVEsQ0FBQztBQUV2QixVQUFNLE1BQU0sTUFBTSxJQUFJLEtBQUssWUFBWSxPQUFPLENBQUMsRUFBRTtBQUNqRCxPQUFHLFVBQVUsYUFBWSxjQUFHLFlBQVksR0FBRyxNQUFsQixtQkFBcUIsUUFBckIsWUFBNEI7QUFDckQsV0FBTyxVQUFVLEVBQUUsTUFBTSxZQUFZLE1BQU0sSUFBSSxFQUFFLENBQUM7QUFBQSxFQUNwRDtBQUNGOyIsCiAgIm5hbWVzIjogWyJsZXZlbCJdCn0K
